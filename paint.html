<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>MiRoDot Editor v2</title>
    <style>
        /* --- 基本デザイン（ダークモード） --- */
        body { 
            font-family: sans-serif; display: flex; flex-direction: column; align-items: center; 
            background: #121212; color: white; padding: 10px; margin: 0;
            overflow-x: hidden;
            transition: background 0.3s, color 0.3s;
        }
        
        /* --- ライトモード用設定 --- */
        body.light-mode { background: #f0f0f0; color: #333; }

        .editor-layout { display: flex; gap: 15px; align-items: flex-start; margin-bottom: 15px; max-width: 100vw; }
        
        .grid-container { 
            width: 320px; height: 320px; 
            background-color: #1a1a1a;
            background-image: linear-gradient(45deg, #222 25%, transparent 25%), linear-gradient(-45deg, #222 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #222 75%), linear-gradient(-45deg, transparent 75%, #222 75%);
            background-size: 20px 20px; background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            border: 2px solid #444; position: relative; 
            touch-action: none; 
        }
        body.light-mode .grid-container {
            background-color: #ffffff;
            background-image: linear-gradient(45deg, #ddd 25%, transparent 25%), linear-gradient(-45deg, #ddd 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ddd 75%), linear-gradient(-45deg, transparent 75%, #ddd 75%);
            border-color: #bbb;
        }

        #grid { display: grid; grid-template-columns: repeat(16, 1fr); grid-template-rows: repeat(16, 1fr); width: 100%; height: 100%; }
        .cell { width: 100%; height: 100%; cursor: crosshair; box-sizing: border-box; border: 0.5px solid rgba(255, 255, 255, 0.1); }
        body.light-mode .cell { border: 0.5px solid rgba(0, 0, 0, 0.05); }
        #grid.no-grid .cell { border: none; }

        .preview-pane { display: flex; flex-direction: column; align-items: center; background: #1e1e1e; padding: 10px; border-radius: 8px; border: 1px solid #333; }
        body.light-mode .preview-pane { background: #e0e0e0; border-color: #bbb; }
        
        .preview-box { width: 64px; height: 64px; display: grid; grid-template-columns: repeat(16, 1fr); background: #000; }
        body.light-mode .preview-box { background: #fff; border: 1px solid #ccc; }
        .p-pixel { width: 100%; height: 100%; }

        .palette-selector { display: flex; gap: 5px; flex-wrap: wrap; width: 95vw; margin-bottom: 10px; justify-content: center; }
        .pal-btn { padding: 8px 10px; font-size: 12px; cursor: pointer; background: #333; border: 1px solid #555; color: #aaa; border-radius: 4px; }
        body.light-mode .pal-btn { background: #ddd; border-color: #ccc; color: #666; }
        .pal-btn.active { background: #9146ff; color: white; border-color: #fff; }
        
        .palette { display: flex; gap: 6px; flex-wrap: wrap; width: 95vw; justify-content: center; margin-bottom: 15px; }
        .p-color { width: 40px; height: 40px; cursor: pointer; border: 2px solid #444; border-radius: 6px; position: relative; box-sizing: border-box; }
        body.light-mode .p-color { border-color: #ccc; }
        .p-color.selected { border-color: #fff; transform: scale(1.1); box-shadow: 0 0 12px rgba(255,255,255,0.5); z-index: 10; }
        body.light-mode .p-color.selected { border-color: #9146ff; }
        
        .p-transparent { background-color: #333 !important; }
        body.light-mode .p-transparent { background-color: #eee !important; }
        .p-transparent::after { content: "×"; color: #ff4444; font-size: 24px; font-weight: bold; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }

        .tool-box { display: flex; gap: 8px; margin-bottom: 10px; background: #222; padding: 10px; border-radius: 8px; border: 1px solid #333; }
        body.light-mode .tool-box { background: #e0e0e0; border-color: #bbb; }
        .tool-btn { padding: 10px 12px; cursor: pointer; border: 1px solid #444; background: #333; color: white; border-radius: 4px; font-size: 13px; }
        body.light-mode .tool-btn { background: #ddd; border-color: #ccc; color: #333; }
        .tool-btn.active { border-color: #9146ff; background: #9146ff; color: white !important; }
        
        .controls { display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; }
        button { padding: 12px 18px; cursor: pointer; border: none; border-radius: 5px; font-weight: bold; color: white; font-size: 14px; }
        .btn-undo { background: #6e44ff; } .btn-redo { background: #27ae60; } .btn-clear { background: #555; } .btn-gen { background: #9146ff; }
        
        textarea { width: 90vw; height: 60px; margin-top: 15px; background: #000; color: #00ff00; border: 1px solid #333; font-family: monospace; padding: 8px; border-radius: 4px; resize: none; font-size: 12px; }
        body.light-mode textarea { background: #fff; border-color: #ccc; color: #008000; }

        /* --- 保存セクション --- */
        .save-section { margin-top: 20px; display: flex; flex-direction: column; align-items: center; gap: 10px; padding: 15px; background: #222; border-radius: 8px; width: 90vw; }
        body.light-mode .save-section { background: #e0e0e0; border: 1px solid #bbb; }
        .save-options { display: flex; gap: 10px; font-size: 14px; align-items: center; flex-wrap: wrap; justify-content: center; }
        .btn-save { background: #2ecc71; width: 200px; }
        .btn-save:hover { background: #27ae60; }

        /* 右側パネルを縦に並べる設定 */
        .side-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }

        .color-edit-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            background: #1e1e1e;
            padding: 8px;
            border-radius: 8px;
            border: 1px solid #333;
            width: 64px;
            box-sizing: border-box;
        }

        body.light-mode .color-edit-panel {
            background: #e0e0e0;
            border-color: #bbb;
        }

        .panel-label { font-size: 9px; color: #888; }
        #current-hex { font-size: 10px; font-family: monospace; color: #9146ff; font-weight: bold; }
        
        .btn-color-edit { width: 100%; padding: 5px 0 !important; font-size: 11px !important; }
        
        /* リセットボタンの独自スタイル */
        .btn-reset {
            width: 100%;
            padding: 3px 0 !important;
            font-size: 10px !important;
            background: #444 !important;
            border: 1px solid #555 !important;
            margin-top: 2px;
        }

        #color-input { visibility: hidden; width: 0; height: 0; position: absolute; }

        @media (min-width: 600px) {
            .grid-container { width: 352px; height: 352px; }
            .palette, .palette-selector { width: 580px; }
            textarea, .save-section { width: 480px; }
        }
    </style>
</head>
<body id="main-body">
    <div class="tool-box">
        <div id="btn-pen" class="tool-btn active" onclick="setTool('pen')">ペン [R]</div>
        <div id="btn-fill" class="tool-btn" onclick="setTool('fill')">バケツ [F]</div>
        <div id="btn-picker" class="tool-btn" onclick="setTool('picker')">スポイト [Q]</div>
        <div id="btn-grid" class="tool-btn active" onclick="toggleGrid()">枠 [I]</div>
        <div id="btn-theme" class="tool-btn" onclick="toggleTheme()">背景 [O]</div>
    </div>

    <div class="editor-layout">
        <div class="grid-container"><div id="grid"></div></div>

        <div class="side-controls">
            <div class="preview-pane">
                <div id="preview" class="preview-box"></div>
            </div>

            <div class="color-edit-panel">
                <div class="panel-label">色変更</div>
                <div id="current-hex">#FFFFFF</div>
                <button class="tool-btn btn-color-edit" onclick="openColorPicker()">変更</button>
                <button class="tool-btn btn-reset" onclick="resetCurrentPalette()">reset</button>
                <input type="color" id="color-input" oninput="updateCurrentPaletteColor(this.value)">
            </div>
        </div>
    </div>

    <div class="palette-selector" id="pal-selector"></div>
    <div class="palette" id="palette"></div>
    
    <div class="controls">
        <button class="btn-undo" onclick="undo()">[Z] 戻る</button>
        <button class="btn-redo" onclick="redo()">[Y] 進む</button>
        <button class="btn-clear" onclick="clearGrid()">消去</button>
        <button class="btn-gen" onclick="generateCode()">コード生成</button>
    </div>
    
    <textarea id="output" readonly placeholder="ここにコードが生成されます"></textarea>

    <div class="save-section">
        <div class="save-options">
            <span>倍率:</span>
            <label><input type="radio" name="scale" value="1"> 1x</label>
            <label><input type="radio" name="scale" value="2"> 2x</label>
            <label><input type="radio" name="scale" value="4" checked> 4x</label>
            <label><input type="radio" name="scale" value="8"> 8x</label>
            <label><input type="radio" name="scale" value="16"> 16x</label>
        </div>
        <button class="btn-save" onclick="downloadPNG()">PNGとして保存</button>
    </div>

</body>
</html>
<script>
/**
 * paint.js - MiRoDot Editor v2
 * パレット変更検知・条件付きエンコーディング対応版
 */

// デフォルトパレット（リセット用・不変）
const DEFAULT_PALETTES = {
    "基本": ['transparent','#ffffff','#888888','#222222','#ff4b2b','#33cc33','#0077ff','#ffee00','#ff99cc','#66ffff','#ccff33','#8b4513','#b22222','#000080','#ff8c00','#000000'],
    "人物": ['transparent','#fff5eb','#fde5d2','#f9d4b8','#f3b08c','#e3906c','#c07254','#91553d','#ff66a3','#ff0066','#9900ff','#442211','#55ccff','#ffffff','#222222','#000000'],
    "モノクロ": ['transparent','#ffffff','#f8f8f8','#e0e0e0','#cccccc','#b0b0b0','#999999','#808080','#666666','#505050','#404040','#303030','#202020','#101010','#050505','#000000'],
    "暖色": ['transparent','#ff6b6b','#fa5252','#f03e3e','#e03131','#c92a2a','#ffa94d','#fd7e14','#f76707','#e8590c','#d9480f','#ffffff','#ffec99','#fab005','#222222','#000000'],
    "寒色": ['transparent','#339af0','#228be6','#1c7ed6','#1971c2','#1864ab','#38d9a9','#20c997','#12b886','#0ca678','#099268','#ffffff','#a5d8ff','#111111','#222222','#000000'],
    "ファミコン": ['transparent','#f8f8f8','#bcbcbc','#7c7c7c','#f8d878','#f8a000','#f83800','#d80000','#008800','#00a800','#0058f8','#3cbcfc','#0000bc','#6844fc','#ffffff','#000000'],
    "パステル": ['transparent','#ffb7b2','#ffdac1','#e2f0cb','#b5ead7','#c7ceea','#ffc6ff','#9bf6ff','#a0c4ff','#bdb2ff','#fffffc','#ffffff','#333333','#aaaaaa','#222222','#000000'],
    "赤黒白": ['transparent','#ff0000','#cc0000','#990000','#660000','#330000','#ff8888','#ffcccc','#ffffff','#eeeeee','#cccccc','#999999','#666666','#333333','#111111','#000000'],
    "サイバー": ['transparent','#00ff00','#ff00ff','#00ffff','#ffff00','#ff0000','#ffffff','#003300','#330033','#003333','#333300','#330000','#444444','#888888','#222222','#000000'],
    "森": ['transparent','#2d5a27','#1e3f1a','#4a7c44','#6b8e23','#8fbc8f','#556b2f','#a2ad91','#deb887','#8b4513','#5d4037','#ffffff','#cccccc','#444444','#222222','#000000'],
    "海": ['transparent','#0077be','#005b96','#03396c','#011f4b','#6497b1','#b3cde0','#009688','#4db6ac','#80cbc4','#ffffff','#dddddd','#aaaaaa','#333333','#111111','#000000'],
    "夕焼け": ['transparent','#ff4500','#ff6347','#ff8c00','#ffa500','#ffd700','#2f4f4f','#708090','#191970','#000080','#483d8b','#ffffff','#aaaaaa','#333333','#111111','#000000'],
    "GB風": ['transparent','#9bbc0f','#8bab0f','#306230','#0f380f','#ffffff','#dddddd','#bbbbbb','#999999','#777777','#555555','#333333','#111111','#050505','#222222','#000000'],
    "和風": ['transparent','#a63d33','#e0815e','#6b4a3e','#f2e8d5','#bfbd97','#8c9e5e','#5e6146','#3e4a3d','#2b3a2d','#1a201a','#ffffff','#cccccc','#888888','#222222','#000000'],
    "ベリー": ['transparent','#5d001e','#9a1750','#ee4c7c','#ff66aa','#cc3366','#990033','#ffcccc','#ff99cc','#ffffff','#eeeeee','#cccccc','#999999','#444444','#222222','#000000'],
    "原色": ['transparent','#ff0000','#00ff00','#0000ff','#ffff00','#ff00ff','#00ffff','#ffffff','#808080','#800000','#008000','#000080','#808000','#800080','#444444','#000000']
};

// 現在のパレット（編集可能）
let PALETTES = JSON.parse(JSON.stringify(DEFAULT_PALETTES));

// グローバル変数
let cells = [];
let currentPalKey = "基本";
let selectedIdx = 1;
let prevIdx = 1;
let currentTool = "pen";
let isDrawing = false;
let undoStack = [];
let redoStack = [];
let isPaletteModified = false; // パレット変更フラグ

// LocalStorageからパレットを読み込み
function loadPalettesFromLocal() {
    const stored = localStorage.getItem('mirodot_palettes_v2');
    if (stored) {
        try {
            PALETTES = JSON.parse(stored);
        } catch (e) {
            console.error('パレット読み込みエラー:', e);
        }
    }
}

// LocalStorageにパレットを保存
function savePalettesToLocal() {
    localStorage.setItem('mirodot_palettes_v2', JSON.stringify(PALETTES));
}

// 初期化
loadPalettesFromLocal();

const grid = document.getElementById('grid');
const preview = document.getElementById('preview');

// 16x16グリッドを生成
for (let i = 0; i < 256; i++) {
    const cell = document.createElement('div');
    cell.className = 'cell';
    cell.dataset.idx = "0";
    cell.addEventListener('mousedown', (e) => { e.preventDefault(); isDrawing = true; handleDraw(i); });
    cell.addEventListener('mouseenter', () => { if (isDrawing) handleDraw(i); });
    cell.addEventListener('touchstart', (e) => { e.preventDefault(); isDrawing = true; handleDraw(i); });
    cell.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        const target = document.elementFromPoint(touch.clientX, touch.clientY);
        if (target && target.classList.contains('cell')) {
            const idx = Array.from(cells).indexOf(target);
            if (idx !== -1) handleDraw(idx);
        }
    });
    grid.appendChild(cell);
    cells.push(cell);
}

// プレビュー用ピクセル生成
for (let i = 0; i < 256; i++) {
    const pPixel = document.createElement('div');
    pPixel.className = 'p-pixel';
    preview.appendChild(pPixel);
}

// パレット選択ボタン生成
function renderPalette() {
    const selector = document.getElementById('pal-selector');
    selector.innerHTML = '';
    Object.keys(PALETTES).forEach(key => {
        const btn = document.createElement('div');
        btn.className = 'pal-btn';
        btn.innerText = key;
        if (key === currentPalKey) btn.classList.add('active');
        btn.onclick = () => {
            currentPalKey = key;
            isPaletteModified = false; // パレット切り替え時はフラグリセット
            renderPalette();
            refreshColors();
        };
        selector.appendChild(btn);
    });
}

// カラーパレット表示
function refreshColors() {
    const palette = document.getElementById('palette');
    palette.innerHTML = '';
    const colors = PALETTES[currentPalKey];
    
    colors.forEach((color, idx) => {
        const pColor = document.createElement('div');
        pColor.className = 'p-color';
        if (idx === 0) pColor.classList.add('p-transparent');
        if (idx === selectedIdx) pColor.classList.add('selected');
        pColor.style.backgroundColor = color;
        pColor.onclick = () => selectColor(idx);
        palette.appendChild(pColor);
    });

    // グリッドとプレビューの更新
    cells.forEach((cell, i) => {
        const idx = parseInt(cell.dataset.idx);
        cell.style.backgroundColor = colors[idx] || 'transparent';
        preview.children[i].style.backgroundColor = colors[idx] || 'transparent';
    });
}

// 色選択
function selectColor(idx) {
    prevIdx = selectedIdx;
    selectedIdx = idx;
    const hex = PALETTES[currentPalKey][idx];
    document.getElementById('current-hex').innerText = (idx === 0) ? "TRANS" : hex.toUpperCase();
    refreshColors();
}

// 描画処理
function handleDraw(pos) {
    if (currentTool === 'pen') {
        if (cells[pos].dataset.idx != selectedIdx) {
            if (!isDrawing) saveHistory();
            cells[pos].dataset.idx = selectedIdx;
            refreshColors();
        }
    } else if (currentTool === 'fill') {
        fill(pos);
    } else if (currentTool === 'picker') {
        selectColor(parseInt(cells[pos].dataset.idx));
    }
}

// 塗りつぶし
function fill(pos) {
    saveHistory();
    const targetIdx = cells[pos].dataset.idx;
    if (targetIdx == selectedIdx) return;
    const queue = [pos], processed = new Set();
    while (queue.length > 0) {
        const p = queue.shift();
        if (processed.has(p) || cells[p].dataset.idx !== targetIdx) continue;
        cells[p].dataset.idx = selectedIdx;
        processed.add(p);
        const x = p % 16, y = Math.floor(p / 16);
        if (x > 0) queue.push(p - 1);
        if (x < 15) queue.push(p + 1);
        if (y > 0) queue.push(p - 16);
        if (y < 15) queue.push(p + 16);
    }
    refreshColors();
}

// カラーピッカーを開く
function openColorPicker() {
    if (selectedIdx === 0) {
        alert("透明色は変更できません");
        return;
    }
    document.getElementById('color-input').click();
}

// パレット色変更（フラグを立てる）
function updateCurrentPaletteColor(hex) {
    if (selectedIdx === 0) return;
    isPaletteModified = true; // 変更フラグを立てる
    saveHistory();
    PALETTES[currentPalKey][selectedIdx] = hex.toUpperCase();
    document.getElementById('current-hex').innerText = hex.toUpperCase();
    refreshColors();
    savePalettesToLocal();
}

// パレットリセット（フラグを下ろす）
function resetCurrentPalette() {
    if (confirm(`パレット「${currentPalKey}」を初期の色に戻しますか？`)) {
        isPaletteModified = false; // フラグを下ろす
        saveHistory();
        PALETTES[currentPalKey] = [...DEFAULT_PALETTES[currentPalKey]];
        const hex = PALETTES[currentPalKey][selectedIdx];
        document.getElementById('current-hex').innerText = (selectedIdx === 0) ? "TRANS" : hex.toUpperCase();
        refreshColors();
        savePalettesToLocal();
    }
}

// 履歴保存
function saveHistory() {
    undoStack.push(JSON.stringify({pal: currentPalKey, data: cells.map(c => c.dataset.idx), modified: isPaletteModified}));
    if (undoStack.length > 50) undoStack.shift();
    redoStack = [];
}

// 元に戻す
function undo() {
    if (undoStack.length === 0) return;
    redoStack.push(JSON.stringify({pal: currentPalKey, data: cells.map(c => c.dataset.idx), modified: isPaletteModified}));
    const last = JSON.parse(undoStack.pop());
    currentPalKey = last.pal;
    isPaletteModified = last.modified || false;
    last.data.forEach((idx, i) => { cells[i].dataset.idx = idx; });
    renderPalette();
    refreshColors();
}

// やり直し
function redo() {
    if (redoStack.length === 0) return;
    undoStack.push(JSON.stringify({pal: currentPalKey, data: cells.map(c => c.dataset.idx), modified: isPaletteModified}));
    const next = JSON.parse(redoStack.pop());
    currentPalKey = next.pal;
    isPaletteModified = next.modified || false;
    next.data.forEach((idx, i) => { cells[i].dataset.idx = idx; });
    renderPalette();
    refreshColors();
}

// ツール切り替え
function setTool(t) {
    currentTool = t;
    document.querySelectorAll('.tool-btn').forEach(b => { 
        if (b.id !== 'btn-grid' && b.id !== 'btn-theme') b.classList.remove('active'); 
    });
    document.getElementById('btn-' + t).classList.add('active');
}

// グリッド表示切り替え
function toggleGrid() {
    grid.classList.toggle('no-grid');
    document.getElementById('btn-grid').classList.toggle('active');
}

// テーマ切り替え
function toggleTheme() {
    document.body.classList.toggle('light-mode');
    document.getElementById('btn-theme').classList.toggle('active');
}

// キーボードショートカット
window.addEventListener('keydown', (e) => {
    if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') return;
    const k = e.key.toLowerCase();
    if (k === 'r') setTool('pen');
    if (k === 'f') setTool('fill');
    if (k === 'q') setTool('picker');
    if (k === 'x') selectColor(0);
    if (k === 'a') selectColor(prevIdx);
    if (k === 'z') undo();
    if (k === 'y') redo();
    if (k === 'i') toggleGrid();
    if (k === 'o') toggleTheme();
    if (/[1-9]/.test(k)) selectColor(parseInt(k));
});

// マウス・タッチイベント
window.onmouseup = () => isDrawing = false;
window.addEventListener('touchend', () => isDrawing = false);

// 全消去
function clearGrid() {
    if (confirm("すべて消去しますか？")) {
        saveHistory();
        cells.forEach(c => c.dataset.idx = "0");
        refreshColors();
    }
}

// コード生成（v2形式・パレットID対応・バイナリカスタムカラー対応・ハイブリッド圧縮）
function generateCode() {
    const pixels = cells.map(c => parseInt(c.dataset.idx));
    const palKeys = Object.keys(PALETTES);
    const setId = palKeys.indexOf(currentPalKey);
    const palIdHex = setId.toString(16); // 0-f

    // カスタムカラー検出
    const currentPalette = PALETTES[currentPalKey];
    const defaultPalette = DEFAULT_PALETTES[currentPalKey];
    const customColors = [];
    
    for (let i = 0; i < 16; i++) {
        if (currentPalette[i] !== defaultPalette[i]) {
            // 色が変更されている
            const color = currentPalette[i];
            if (color !== 'transparent') {
                const hex = color.replace('#', '');
                const r = parseInt(hex.substring(0, 2), 16);
                const g = parseInt(hex.substring(2, 4), 16);
                const b = parseInt(hex.substring(4, 6), 16);
                customColors.push({ index: i, r, g, b });
            }
        }
    }

    // === ハイブリッド圧縮: RLE vs Base64 ===
    
    // RLE圧縮を生成
    let rleBody = [];
    let count = 1;
    for (let i = 0; i < pixels.length; i++) {
        if (pixels[i] === pixels[i + 1] && count < 255) {
            count++;
        } else {
            rleBody.push(pixels[i], count);
            count = 1;
        }
    }

    // Base64エンコード（4bitニブル形式: 1バイトに2ピクセル）
    let base64Body = [];
    for (let i = 0; i < pixels.length; i += 2) {
        const pixel1 = pixels[i];
        const pixel2 = (i + 1 < pixels.length) ? pixels[i + 1] : 0;
        base64Body.push((pixel1 << 4) | pixel2);
    }

    // サイズ比較して小さい方を選択
    let finalBody, identifier;
    
    if (rleBody.length <= base64Body.length) {
        finalBody = rleBody;
        identifier = 'r'; // RLE
    } else {
        finalBody = base64Body;
        identifier = 'b'; // Base64ニブル
    }

    // カスタムカラーをバイナリの先頭に追加
    let binaryData = [];
    
    // カスタムカラー数（1バイト）
    binaryData.push(customColors.length);
    
    // カスタムカラーデータ（各4バイト: 番号, R, G, B）
    customColors.forEach(c => {
        binaryData.push(c.index, c.r, c.g, c.b);
    });
    
    // ピクセルデータを追加
    binaryData = binaryData.concat(finalBody);
    
    // Base64エンコード
    const base64String = btoa(String.fromCharCode(...binaryData));
    
    // 最終コード: !miv2 [r/b][パレットID][Base64]
    const finalCode = "!miv2 " + identifier + palIdHex + base64String;

    document.getElementById('output').value = finalCode;
    
    // クリップボードにコピー
    if (navigator.clipboard) {
        navigator.clipboard.writeText(finalCode).then(() => {
            const msg = customColors.length > 0 
                ? `クリップボードにコピーしました\n（カスタムカラー ${customColors.length}色を含む）`
                : "クリップボードにコピーしました";
            alert(msg);
        });
    }
}

// PNGダウンロード
function downloadPNG() {
    const scale = parseInt(document.querySelector('input[name="scale"]:checked').value);
    const size = 16 * scale;
    
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');
    
    // アンチエイリアスを無効にしてドットをクッキリさせる
    ctx.imageSmoothingEnabled = false;

    cells.forEach((cell, i) => {
        const x = (i % 16) * scale;
        const y = Math.floor(i / 16) * scale;
        const idx = parseInt(cell.dataset.idx);
        const color = PALETTES[currentPalKey][idx];

        if (color === 'transparent') {
            ctx.clearRect(x, y, scale, scale);
        } else {
            ctx.fillStyle = color;
            ctx.fillRect(x, y, scale, scale);
        }
    });

    const link = document.createElement('a');
    link.download = `mirodot_${size}x${size}.png`;
    link.href = canvas.toDataURL('image/png');
    link.click();
}

// 初回レンダリング
renderPalette();
refreshColors();
saveHistory();
</script>
